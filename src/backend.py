# System interaction layer. Reads sensor data from the 'sensors' command,
# controls fan speed via /proc/acpi/ibm/fan, and handles all I/O
# operations for thinkfan.conf files.

import yaml
import subprocess
import os
import sys
import re
import json
from data_model import TempRange

THINKFAN_CONF_PATH = "/etc/thinkfan.conf"
HELPER_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), "save_helper.py"))

def discover_sensors():
    """
    Runs 'sensors -j' and parses the output to get a list of all
    individual temperature sensors on the system.
    """
    try:
        result = subprocess.run(
            ["sensors", "-j"], 
            capture_output=True, 
            text=True, 
            check=True
        )
        sensor_data = json.loads(result.stdout)
    except Exception as e:
        print(f"Error discovering sensors: {e}", file=sys.stderr)
        return []

    all_sensors = []
    for device_name, device_info in sensor_data.items():
        hwmon_name = device_name.split('-')[0]
        for feature_name, feature_data in device_info.items():
            if not isinstance(feature_data, dict): continue
            for key in feature_data:
                if key.endswith("_input") and key.startswith("temp"):
                    index = int(re.search(r'temp(\d+)_input', key).group(1))
                    all_sensors.append({
                        'device': hwmon_name,
                        'label': feature_name,
                        'index': index
                    })
    return all_sensors

def save_content_to_thinkfan(content):
    """
    Generic helper function that saves any string content to the thinkfan.conf
    file using the privileged helper script.
    """
    try:
        command = ["pkexec", sys.executable, HELPER_PATH, THINKFAN_CONF_PATH, content]
        result = subprocess.run(command, capture_output=True, text=True)
        
        if result.returncode == 0:
            return True
        else:
            print(f"Helper script failed: {result.stderr}", file=sys.stderr)
            return False
    except Exception as e:
        print(f"Error executing helper script: {e}", file=sys.stderr)
        return False

def generate_config_content(selected_sensors):
    """
    Generates the full text content for a new thinkfan.conf file based on
    the user's sensor selection from the wizard.
    """
    if not selected_sensors:
        return ""

    output_str = "# Autogenerated by thinkfan-ui Configuration Wizard\n\n"
    output_str += "fans:\n"
    output_str += "  - tpacpi: /proc/acpi/ibm/fan\n\n"
    output_str += "sensors:\n"

    sensor_groups = {}
    for sensor in selected_sensors:
        device_name = sensor['device']
        if device_name not in sensor_groups:
            sensor_groups[device_name] = []
        sensor_groups[device_name].append(sensor)

    for device, sensors_in_group in sensor_groups.items():
        indices = sorted([s['index'] for s in sensors_in_group])
        output_str += f"  - hwmon: /sys/class/hwmon\n"
        output_str += f"    name: {device}\n"
        output_str += f"    indices: {str(indices)}\n"
        output_str += f"    # Mappings for {device}:\n"
        sorted_sensors_in_group = sorted(sensors_in_group, key=lambda s: s['index'])
        for sensor in sorted_sensors_in_group:
            output_str += f"    #   {sensor['index']}: {sensor['label']}\n"
        output_str += "\n"

    output_str += "levels:\n"

    default_levels = [
        [0, 0, 55], [2, 50, 65], [4, 60, 75],
        [7, 70, 85], [127, 80, 100]
    ]

    if len(selected_sensors) == 1:
        output_str += "# Using simple syntax as only one sensor is active.\n"
        for level in default_levels:
            output_str += f"  - {str(level)}\n"
    else:
        output_str += "# Using detailed syntax for multiple sensors.\n"
        output_str += "# A default curve has been applied to all sensors.\n"
        num_sensors = len(selected_sensors)
        for level, min_temp, max_temp in default_levels:
            lower_limits = [min_temp] * num_sensors
            upper_limits = [max_temp] * num_sensors
            output_str += f"  - speed: {level}\n"
            output_str += f"    lower_limit: {str(lower_limits)}\n"
            output_str += f"    upper_limit: {str(upper_limits)}\n"

    return output_str.replace("'", "")

def load_curve_from_thinkfan():
    """
    Reads /etc/thinkfan.conf and returns a dictionary where keys are sensor
    labels (e.g. "CPU", "GPU") and values are their corresponding fan curves.
    """
    try:
        with open(THINKFAN_CONF_PATH, 'r') as f:
            config = yaml.safe_load(f)
    except Exception as e:
        print(f"Error reading {THINKFAN_CONF_PATH}: {e}", file=sys.stderr)
        return {}

    if not isinstance(config, dict) or 'sensors' not in config or 'levels' not in config:
        return {}

    # Get a fresh map of all sensor labels on the system
    system_sensors = discover_sensors()
    # Create a lookup table: (device_name, index) -> label
    label_lookup = {(s['device'], s['index']): s['label'] for s in system_sensors}

    # Build an ordered map of sensors as defined in the config file
    sensor_map = []
    for sensor_block in config.get('sensors', []):
        if isinstance(sensor_block, dict) and 'name' in sensor_block and 'indices' in sensor_block:
            name = sensor_block['name']
            for index in sensor_block['indices']:
                # Find the label for this sensor from our system-wide lookup
                label = label_lookup.get((name, index), f"{name}-idx{index}")
                sensor_map.append({'name': name, 'index': index, 'label': label})

    if not sensor_map: return {}

    curves = {}
    levels_data = config.get('levels', [])
    if not levels_data: return {}

    first_level_entry = levels_data[0]

    # Handle Simple Syntax
    if isinstance(first_level_entry, list):
        # In simple mode, there is one curve. We'll use the first sensor's label as the key.
        curve_key = sensor_map[0]['label']
        curves[curve_key] = []
        for entry in levels_data:
            if isinstance(entry, list) and len(entry) == 3:
                level, min_temp, max_temp = entry
                level = "Disengaged" if level == 127 else level
                curves[curve_key].append(TempRange(min_temp=min_temp, max_temp=max_temp, level=level))

    # Handle Detailed Syntax
    elif isinstance(first_level_entry, dict):
        # Initialize a curve list for each unique sensor label
        for sensor in sensor_map:
            if sensor['label'] not in curves:
                curves[sensor['label']] = []

        for level_entry in levels_data:
            if not all(k in level_entry for k in ['speed', 'lower_limit', 'upper_limit']):
                continue
            
            level = level_entry['speed']
            level = "Disengaged" if level == 127 else level

            for i, sensor_info in enumerate(sensor_map):
                try:
                    label = sensor_info['label']
                    min_temp = level_entry['lower_limit'][i]
                    max_temp = level_entry['upper_limit'][i]
                    curves[label].append(TempRange(min_temp=min_temp, max_temp=max_temp, level=level))
                except (IndexError, TypeError):
                    continue
    
    return curves

def save_curve_to_thinkfan(curves_dict):
    """
    Writes a dictionary of curves (keyed by sensor label) to /etc/thinkfan.conf
    using the detailed syntax.
    """
    header_lines = []
    config_sensors = [] # Store the structured sensor data from the file
    
    try:
        with open(THINKFAN_CONF_PATH, 'r') as f:
            content = f.read()
            config = yaml.safe_load(content)
            config_sensors = config.get('sensors', [])
            
            # Read the file content up to the 'levels:' section to preserve it
            header_lines = content.split('levels:')[0]

    except (FileNotFoundError, Exception):
        return False # Cannot save if we can't read the sensor layout

    # Build an ordered map of every sensor input from the file
    sensor_map = []
    for sensor_block in config_sensors:
        name = sensor_block.get('name')
        indices = sensor_block.get('indices', [])
        for index in indices:
            sensor_map.append({'name': name, 'index': index})

    # Get a system-wide lookup for labels to find the label for each sensor in the map
    system_sensors = discover_sensors()
    label_lookup = {(s['device'], s['index']): s['label'] for s in system_sensors}
    for sensor in sensor_map:
        sensor['label'] = label_lookup.get((sensor['name'], sensor['index']), f"{sensor['name']}-idx{sensor['index']}")

    # --- Build the new 'levels' section ---
    final_content = header_lines.strip() + "\n\nlevels:\n"
    
    all_levels = set()
    for curve in curves_dict.values():
        for temp_range in curve:
            all_levels.add(temp_range.level)
    
    sorted_levels = sorted(list(all_levels), key=lambda x: (isinstance(x, str), x))

    for level in sorted_levels:
        speed = 127 if str(level) == 'Disengaged' else level
        final_content += f"  - speed: {speed}\n"
        
        lower_limits = []
        upper_limits = []
        
        for sensor in sensor_map:
            label = sensor['label']
            curve = curves_dict.get(label, [])
            found_range = next((r for r in curve if r.level == level), None)
            
            if found_range:
                lower_limits.append(found_range.min_temp)
                upper_limits.append(found_range.max_temp)
            else:
                # Fallback: if a sensor doesn't have a rule for a specific level,
                # give it a non-interfering wide range.
                lower_limits.append(0)
                upper_limits.append(120)

        final_content += f"    lower_limit: {str(lower_limits)}\n"
        final_content += f"    upper_limit: {str(upper_limits)}\n"

    return save_content_to_thinkfan(final_content.replace("'", ""))
